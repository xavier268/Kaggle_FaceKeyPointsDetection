---
title: "5e.morphing"
output: 
  html_document: 
    toc: yes
---

# Using various transformations of the image to try to match a "standard" image via morphing.

## Loading the data

We load from the compiled, preformatted data saved earlier :

```{r Loading environement}
load("d.train.RData")
load("im.train.RData")
load("im.test.RData")
load("functions.viewing.RData")
set.seed(24)
ls()
```

## Computing the 'average' image

We will only use complete images.

```{r compute average image}

im.average <- colMeans(im.train[d.train.complete,])
m.plotImage(im.average, kp=d.key.mean)

```

## Interpolating utility for an image (bilinear)

x and y and any real points, but within valid index ranges
imat must be an image matrix, any size.

```{r}
c.interpolateImg <- function(imat, x,y) {
  
  xx <- floor(x)
  yy <- floor(y)
  
  lambda <- x - xx  # 0<= lambda < 1
  mu <- y - yy
  
  if(lambda==0 & mu==0) {
    return (imat[x,y])
  }
  if(lambda == 0) {
    return (
    mu*imat[xx,yy+1]
    +(1-mu)*imat[xx,yy]
    )
  }
  if(mu==0) {
    return (
    (1-lambda)*imat[xx,yy]
    +lambda*imat[xx+1,yy]
    )
  }
  return (
    lambda*mu*imat[xx+1,yy+1]
    +(1-lambda)*mu*imat[xx,yy+1]
    +(1-lambda)*(1-mu)*imat[xx,yy]
    +lambda*(1-mu)*imat[xx+1,yy]
    )
  
}
```

Lets check by zooming in a picture ...

```{r}
imat <- matrix(rev(im.train[1,]),96,96)
image(imat,asp=1.)
imat2 <- matrix(0,133,133)
for(x in 1:133){
  for(y in 1:133){
    imat2[x,y] <- c.interpolateImg(imat,1 + (x-1)*95/132, 1 + (y-1)*95/132)
  }
}
image(imat2, asp=1.)
```

Sounds good.

## Defining parametrized transformation to an image

We define the transformation using points that are mapped to other points. There are defined with a 3 x 4 matrix. The first 2 colums are the new points in the image coordinates. The last two are the originating points coordinates.

We call this matrix M (3 x 4).

```{r}

c.transformPoint<- function (x,y,M) {
  M<-matrix(M,3,4)
  A <- t(cbind(c(1,1,1),M[,1:2]))
  B <- c(1,x,y)
  # we want to solve A. Alpha  = B
  Alpha <- solve(A,B) # Alpha contains the barycentric coordinates
  
# Now, re recompute the cartesian coordiantes with the new points
  A2 <- t(cbind(c(1,1,1),M[,3:4]))
  B2 <- A2 %*% Alpha
  return (c(B2[2:3]))
}

```

Testing ...

```{r}
M <- c(1,3,1,1,1,2,1,3,2,1,2,2)
M
c.transformPoint(2,2,M)
c.transformPoint(2,1,M)
c.transformPoint(2,1.5,M)
c.transformPoint(3,3,M)
```

OK.

We define imageTransformation, with new parameters, a and b, so that the value in the neaw image is 'a . (old value) + b'

```{r}
c.transformImg<-function(im,M, nrow=96, ncol=96, def=0,a=1,b=0 ) {
  im1 <- matrix(im,nrow,ncol)
  im2 <- matrix(def,nrow,ncol)
  for(x in 1:nrow){
    for(y in 1:ncol){
      X <- c.transformPoint(x,y,M)
      if(all(X>=1 & X<=min(nrow,ncol))){
        im2[x,y] <- c.interpolateImg(im1,X[1],X[2])
      }
    }
  }
  return (c(im2))
}
```

We now define a deformation, based on a vector of parameter that take values between -1 and 1. O means no effect. Size of param is elements.

* first 12 params are mouvements of the eyes/mouth
* next 2 params are the (a,b) parameters for contrast/ight of image

```{r}

c.deformImg <- function (im, param){
  M <-c(
    d.key.mean["left_eye_center_x"],
    d.key.mean["right_eye_center_x"],
    d.key.mean["mouth_center_bottom_lip_x"],
    d.key.mean["left_eye_center_y"], 
    d.key.mean["right_eye_center_y"],
    d.key.mean["mouth_center_bottom_lip_y"],
    d.key.mean["left_eye_center_x"], 
    d.key.mean["right_eye_center_x"],
    d.key.mean["mouth_center_bottom_lip_x"],
    d.key.mean["left_eye_center_y"], 
    d.key.mean["right_eye_center_y"],
    d.key.mean["mouth_center_bottom_lip_y"]
  )
 M <- M + param[1:12] * 20 # +/- 20 pixels
 a <- param[13] + 1.5 # contrast ratio 0.5 : 2.5
 b <- param[14] * 128 # +/- 128 light 
 return(c.transformImg(im, M, a=a, b=b))
}
```



## Defining the cost function

Images must be the same size.

```{r}

c.costImg<- function(im1, im2) {
  im1 <- matrix(im1,96,96)
  im2 <- matrix(im2,96,96)
  res <- 
      (im1[30:80,10:30] - im2[30:80,10:30])^2
      +  (im1[20:80,50:80] - im2[20:80,50:80])^2
  return (sum(res) / (96*96*2))
}

```

Testing ...

```{r}
M <- matrix(c(10,30,10,30,
              10,80, 45, 80,
              80,80,80,80
              ),3,4, byrow = TRUE)

im1 <- im.train[1,]
m.plotImage(im1)
points(M[,3],M[,4])
m.plotImage(c.transformImg(im1,M))
points(M[,1],M[,2])

im2 <- c.deformImg(im1, rep(0,14))
m.plotImage(im2)
c.costImg(im1,im2)

im2 <- c.deformImg(im1, runif(14,-0.8,0.8))
m.plotImage(im2)
c.costImg(im1,im2)

```

Ok.

## Finding the transformation to minimize the distance with the average image.

```{r}
c.fitImg<-function(im1, im2, lambda = 1e-3) {
  
  par <- runif(14,-0.2,+0.2)
  fn <- function(p) {
    c.costImg(im1, c.deformImg(im2,p))
    + lambda * var(p)
  }
  
  res <- optim(par=par, fn=fn, method="BFGS", control = list(maxit=5000))
  print(res)
  return(res$par)
  

}
```






## Clusterize the key sets

Compute keys clusters

```{r}
kcl.nb <- 30
kcl <- kmeans(d.train[d.train.complete,],kcl.nb)
kcl.im.mean <- matrix(0,kcl.nb,96*96)
m.plotImage(im.average)
for(i in 1:kcl.nb){
  kcl.im.mean[i,] <- colMeans(im.train[d.train.complete,][kcl$cluster==i,])
  m.plotKeypoints(kcl$centers[i,])
}

for(i in 1:kcl.nb){
  m.plotImage(kcl.im.mean[i,],kp=kcl$centers[i,],col="yellow")
  title(main=paste("size : ", kcl$size[i]))
}

```

## Test image allocation

Now, we try to allocate a test image to a cluster, and assume the klsuter center should match the image.

```{r}
kcl.fit <- function(im) {
  im <- c(im)
  d <- rowSums((kcl.im.mean - im) ^2)
  return (which(d==min(d)))
} 
```

Testing 

```{r}

k <- sample(1:nrow(im.test),1)
c <- kcl.fit(im.test[k,])
m.plotImage(im.test[k,],kp=kcl$centers[c,])
title(main=paste("cluster = ",c))

```
