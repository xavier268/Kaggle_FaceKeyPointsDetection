---
title: "4b.Preprocessing images SlidingWindow"
output: 
  html_document: 
    toc: yes
---

# Viewing and understanding the training data

## Loading the data

We load from the compiled, preformatted data saved earlier :

```{r Loading environement}
load("d.train.RData")
load("im.train.RData")
load("functions.viewing.RData")
ls()
```


## Defining sliding windows

The following function generate the indexes for the different sliding windows images, each of size 31x31 = 961 pixels, that one can get from a line from im.train or im.test. The indexes represent the column in a im.train row.

We will identify the subimages by the position (row=i=x, col=j=y) of their center. The center coordinates are valid within 16:81. They take 65 valid positions in both dimensions. There are 65*65 = 4225 "windows".

The subimage will range from (c-15):(c+15) around its "center", to be 31x31 = 961 pixels.

```{r}


im.sw.makeIndexesFromCenter<-function(cx, cy) {
  as.vector(
    (matrix(
      1:9216,
      ncol=96,
      nrow=96))
    [(cx-15):(cx+15),(cy-15):(cy+15)])
}


```


We put a red dot, at (row = 75,col = 40), and then try to grab the subimage centered on it, drawing the red dot at the center of the image.

```{r}

par(mfrow=c(1,2))
image(1:96,1:96,matrix(im.train[4,], ncol=96, nrow=96),col=gray((0:255)/255),asp=1.)
points(75,40,col="red")



image(1:31,1:31,
      matrix(im.train[4,im.sw.makeIndexesFromCenter(75,40)], 
            ncol=31, 
            nrow=31),
            col=gray((0:255)/255),
            asp=1.)
  points(15,15,col="red")


```

Looks great !

## Using generated valid/invalid images for future training

This function will generate random valid subimages from the training set. The parameters are :

* cx, cy : center coordinates
* valid. = TRUE or FALSE

Valid images are choosen only among the non-missing training set for that feature. We first focus on "nose_tip".




```{r}
im.sw.random.eye<- function(valid=TRUE){
  
  k <- sample(
    which(
    !is.na(d.train[,"left_eye_center_x"]) 
    &  !is.na(d.train[,"left_eye_center_x"]) 
    & d.train[,"left_eye_center_x"] <80
    & d.train[,"left_eye_center_y"] <80
    & d.train[,"left_eye_center_x"] >16
    & d.train[,"left_eye_center_y"] >16
    )
  ,1) 
  
  
  cx <- d.train[k,"left_eye_center_x"]
  cy <- d.train[k,"left_eye_center_y"]
  i<- cx
  j<- cy
  
  while(! valid && abs(i-cx)<10 && abs(j-cy)<10) {
    i <- sample(16:81,1)
    j <- sample(16:81,1)
  }
  
  res <- im.train[k,im.sw.makeIndexesFromCenter(i,j)] 
  
  return(res)
}

```


## Testing random sample

```{r}
for(i in 1:10){
  par(mfrow=c(1,2))
  image(1:31,1:31,
      matrix(im.sw.random.eye(), 
            ncol=31, 
            nrow=31),
            col=gray((0:255)/255),
            asp=1.)
  points(15,15,col="green")
  title(main="valid")
  
image(1:31,1:31,
      matrix(im.sw.random.eye(valid = FALSE), 
            ncol=31, 
            nrow=31),
            col=gray((0:255)/255),
            asp=1.)
  points(15,15,col="red")
  title(main="Invalid")
}
```


## Producing a set of random left_eye samples, with the outcome


```{r}

im.sw.sample.leftEye <- matrix(NA,10000,31*31)
# Every 1st line is right, next 4 are wrong

for(i in seq(1,nrow(im.sw.sample.leftEye),5)) {
  
  im.sw.sample.leftEye[i,] <- im.sw.random.eye(valid = TRUE)
  
  im.sw.sample.leftEye[i+1,] <- im.sw.random.eye(valid = FALSE)
  im.sw.sample.leftEye[i+1,] <- im.sw.random.eye(valid = FALSE)
  im.sw.sample.leftEye[i+1,] <- im.sw.random.eye(valid = FALSE)
  im.sw.sample.leftEye[i+1,] <- im.sw.random.eye(valid = FALSE)
}

```

## testing MMLP

```{r testing monmlp}
require(monmlp)

Y <- matrix(rep(c(1,0,0,0,0),10000/5),ncol=1)
X <- im.sw.sample.leftEye

mm <- monmlp.fit(x=X, y=Y, hidden1=20)

monmlp.predict(matrix(im.sw.random.eye(valid=TRUE),nrow=1),mm)
```

## Cleaning and saving

We save selectively what we changed or created.

```{r Saving environment}
save(im.sw.random.eye,im.sw.makeIndexesFromCenter,file="imageSliding.RData")
save(im.sw.sample.leftEye,file="im.sw.sample.leftEye.RData")
ls()

```


*This file was compiled on  `r date()`*
